/*
 --------------------------------------------------------------------
 +---+------+ +---+------+ +---+------+ +---+------+
 | А | D090 | | Р | D0A0 | | а | D0B0 | | р | D180 |
 | Б | D091 | | С | D0A1 | | б | D0B1 | | с | D181 |
 | В | D092 | | Т | D0A2 | | в | D0B2 | | т | D182 |
 | Г | D093 | | У | D0A3 | | г | D0B3 | | у | D183 |
 | Д | D094 | | Ф | D0A4 | | д | D0B4 | | ф | D184 |
 | Е | D095 | | Х | D0A5 | | е | D0B5 | | х | D185 |
 | Ж | D096 | | Ц | D0A6 | | ж | D0B6 | | ц | D186 |
 | З | D097 | | Ч | D0A7 | | з | D0B7 | | ч | D187 |
 | И | D098 | | Ш | D0A8 | | и | D0B8 | | ш | D188 |
 | Й | D099 | | Щ | D0A9 | | й | D0B9 | | щ | D189 |
 | К | D09A | | Ъ | D0AA | | к | D0BA | | ъ | D18A |
 | Л | D09B | | Ы | D0AB | | л | D0BB | | ы | D18B |
 | М | D09C | | Ь | D0AC | | м | D0BC | | ь | D18C |
 | Н | D09D | | Э | D0AD | | н | D0BD | | э | D18D |
 | О | D09E | | Ю | D0AE | | о | D0BE | | ю | D18E |
 | П | D09F | | Я | D0AF | | п | D0BF | | я | D18F |
 +---+------+ +---+------+ +---+------+ +---+------+

 | Ё | D001 | JO
 | ё | D191 |

 0xD001, 0xD090..0xD0BF, 0xD180..0xD18F, 0xD191

 0xD0AA, 0xD0AC, 0xD18A, 0xD18C


 В расширении максимум 8 символов, всё что больше это не расширение

 значит делать будем так. находим последнюю точку в имени, и смотрим
 длинну текста после этой точки включая саму точку, если символов
 больше 8 или меньше или равно 1, значит это не расширение.

 есть ещё файлы, с двумя расширениями, типа .tar.gz

 а ещё былы бы здорово сделать список всех известных типов файлов.

 1. сначала сканируем строку на наличие хлама.

 2. если хлам присутствует, значит файл нужно переименовать.

 имя файла не может быть длиннее 255 символов.

 тип файла и расширение будет определяться из вне. а тут будет
 только обработка строки.

 --------------------------------------------------------------------
 */
#include "strcvt.h"

#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdlib.h>
#include <ctype.h>
#include <unistd.h>

// Variables --------------------------------------------------------
/*
 --------------------------------------------------------------------
 Массив для дранслитерации с кирилицы латиницу
 
 а - a, б - b, в - v, г - g, д - d, е - e , ё - io, ж - zh, з - z,
 и - i, й - j, к - k, л - l, м - m, н - n, о - o, п - p, р - r, с - s
 т - t, у - u, ф - f, х - h, ц - c, ч - ch, ш - sh, щ - shch, ы - y
 э - e, ю - iu, я - ia
 -------------------------------------------------------------------- 
 */
const char translit_array[33][5] = {
	"a\0",  "b\0",    "v\0", "g\0", "d\0", "e\0", "zh\0", "z\0", 
	"i\0",  "j\0",    "k\0", "l\0", "m\0", "n\0", "o\0",  "p\0",
	"r\0",  "s\0",    "t\0", "u\0", "f\0", "h\0", "c\0",  "ch\0", 
	"sh\0", "shch\0", "\0",  "y\0", "\0",  "e\0", "iu\0", "ia\0", "io\0"
};

int strcvt_errno;
int cyr_num; // если 0 транслитерация не нужна
char tmpstr[256];
char out_str[256];

/*
 --------------------------------------------------------------------
 Проверка, является ли символ кирилическим.

 если нет возвращаем 0, если да, возвращаем код символа

 --------------------------------------------------------------------
 */
uint16_t is_utf8_cyrrilic(const char *str)
{
	if (str == 0) {
		return 0;
	}

	if (strlen(str) < 2) {
		return 0;
	}

	if ((((uint8_t)(*str)) == 0xD0 ) ||
		(((uint8_t)(*str)) == 0xD1)) {
		return (uint16_t)((((uint16_t)((uint8_t)(*str))) << 8) |
			((uint16_t)((uint8_t)(*(str + 1)))));
	}

	return 0;
}

/*
 -------------------------------------------------------------------д-
 Возвращает указатель на транслит символа кирилицы.

 если символ не является кирилическим, возвращаем 0.

 --------------------------------------------------------------------
 */
const char *get_utf8_translitted(uint16_t c)
{
	if (c == 0) {
		return NULL;
	}

	if (c >= 0xD090 && c < 0xD0B0) {
		return &translit_array[c - 0xD090][0];
	} else if (c >= 0xD0B0 && c <= 0xD0BF) {
		return &translit_array[c - 0xD0B0][0];
	} else if (c >= 0xD180 && c <= 0xD18F) {
		return &translit_array[((c - 0xD180) + 16)][0];
	} else if (c == 0xD001 || c == 0xD191 || c == 0xD081) {
		/* опять же проблемы стандартов. 'Ё' прописная
		 * имеет код 0xD081
		 */
		return &translit_array[32][0];
	}

	return NULL;
}

void translit_utf8(void)
{
	char *tmpptr = out_str;
	char *trptr = tmpstr;
	const char *tr;
	int l = 0, n = 0;

	while (*tmpptr != 0) {
		tr = get_utf8_translitted(
			is_utf8_cyrrilic(tmpptr));

		if (tr == 0) {
			*trptr = *tmpptr;
			n++;
			if (n >= 255) {
				break;
			}
			trptr++;
			tmpptr++;
			continue;
		}

		tmpptr+=2;
		l = strlen(tr);

		n += l;
		if (n >= 255) {
			break;
		}

		sprintf(trptr, "%s", tr);
		trptr+=l;
	}

	strcpy(out_str, tmpstr);
	memset(tmpstr, 0, 256);
}

/*
 --------------------------------------------------------------------
 Проверка строки.

 Проверить на нулевой указатель, есль 0 возарвщаем -1
 Проверить длинну строки, если 0, возвращаем -2

 Проверить на наличие пробелов
 Проверить на наличие других левых символов
 Проверить на наличие кирилицы

 --------------------------------------------------------------------
 */
int check_string(const char *str)
{
	int ret = 0;
	const char *strptr;

	if (str == NULL) {
		printf("[%s:%d] Bad bointer\n", __FUNCTION__, __LINE__);
		return -1;
	}

	if (strlen(str) == 0) {
		printf("[%s:%d] Bad string\n", __FUNCTION__, __LINE__);
		return -2;
	}

	strptr = str;

	while (*strptr != 0) {
		if (is_utf8_cyrrilic(strptr) != 0) {
			ret++;
			cyr_num++;
			strptr+=2;
			continue;
		}

		if ((isalnum(*strptr) == 0) &&
			(*strptr != '_') &&
			(*strptr != '.')) {
			ret++;
		}
		strptr++;
	}

	return ret;
}

/*
 --------------------------------------------------------------------
 Почистим имя файла от лишних символов

 Определим правило именования файлов. В имени файлов должны быть только
 латинские строчные буквы a-z; цифры 0-9; и символы '_'. Точка должна
 быть только одна для разделения расширения. В конце имени файла может
 быть только одно нижнее подчёркивание, в начале не больше двух.

 --------------------------------------------------------------------
 */
void replace_symbols(void)
{
	char *strptr;

	strptr = tmpstr;

	/* Первый этап переборки имени файла. Все цифры 0..9 и буквы a..z
	 * оставляем. Все буквы A..Z преобразовываем в lower. все остальные
	 * символы заменяем символом '_' нижнее подчёркивание.
	 *
	 */
	while (*strptr != 0) {
		if (isalnum(*strptr) == 0) {
			*strptr = '_';
		}
		*strptr = tolower(*strptr);
		strptr++;
	}

	/* Вторым этапом грохаем все следующие друг за другом символы '_'
	 * и все их в конце файла
	 */
	strptr = strchr(tmpstr, '_');

	if (strptr == 0) {
		return;
	}

	while (strptr != 0) {
		if (*(strptr + 1) == '_') {
			memmove(strptr, strptr + 1, strlen(strptr + 1) + 1);
		} else if (*(strptr + 1) == '\0') {
			*strptr = 0;
		} else {
			strptr++;
		}
		strptr = strchr(strptr, '_');
	}
}

/*
 --------------------------------------------------------------------
 Преобразование строки.

 Сначала проверяем строку на наличие символов не относящихся к
 латинским буквам и цифрам и символы точка и нижнее подчёркивание, а
 так проверяем на наличие кирилицы.

 если этот весь сброд обнаружен, то начинаем конвертировать строку.

 сначала выполняем транслитерацию, если нужна, а затем убивае лишние
 символы.

 в случае успеха, функция возвращает указатель на преобразованную строку.
 Иначе возвращает нулевой указатель. и значение в cnf_errno

 --------------------------------------------------------------------
 */
char *convert_string(const char *str)
{
	int ret;
	strcvt_errno = 0;
	cyr_num = 0;

	if ((ret = check_string(str)) <= 0) {
		strcvt_errno = ret;
		return NULL;
	}

	if (strlen(str) > 255) {
		strncpy(out_str, str, 255);
		out_str[255] = 0;
	} else {
		strcpy(out_str, str);
	}

	if (cyr_num > 0) {
		translit_utf8();
	}

	replace_symbols();

	return out_str;
}

const char no_error[] = "no error";
const char bad_pointer_strerr[] = "input string pointer is NULL";
const char bad_string_strerr[] = "lenght of input string NULL";
const char unknown_error_strerr[] = "unknown error";

const char * strcvt_strerr(int err)
{
	switch (err) {
		case 0: return no_error;
		case -1: return bad_pointer_strerr;
		case -2: return bad_string_strerr;
		default: return unknown_error_strerr;
	}
}
